% 明示的状態とセキュリティ

% 安全な抽象は，以下3個のうち1個以上を使う
%   1. 手続き値 (字句的スコープによる隠蔽)
%   2. 名前値 (偽造不可, 推測不可)
%   3. チャンク (選択的アクセスを提供する)

% 問: こうして見ると明示的状態はセキュリティに役立っていないように見えるがそうなのか?


%%% 3.7.4 安全な抽象データ型 (p.207)

% 抽象データ型を安全にするには，ADTの値の内部表現を不当な干渉から護ること．
% 保護すべき値を "保護境界(protection boundary)"と呼び，使い方は以下の二通りある

% 1. 停留値 (Stationary value)
%   * 値は境界から出ない．一定の操作が境界に入り，計算できる．結果は境界内にとどまる．
%   * 6.4節(p.431)でこちらの実装方法を示し，セキュリティに対する明示的状態の効果を説明する(と予告)
% 2. 可動値 (Mobile value)
%   * 値は境界を出ることができる．境界の外にあるとき，値に操作を施すことができる．結果は境界内に戻される．
%   * 宣言的モデルではこちらが理解しやすい．境界に入るために必要な権限を名前(name)と呼ぶ．

% つまり手続きがboundary内に刺さって中で作用するか，boundaryから引っ張りだしてまた戻すか．


%%% 6.4. データ抽象 (p.431)

%% "安全で宣言的な，バンドルされているスタック"

% レキシカルスコープによって隠蔽するやりかた．

% > データ抽象を安全にするのに明示的状態も名前も要らない，という注目すべき事実を実証している．
% > 高階プログラミングだけでできるのである．


%%% 参考: https://github.com/Altech/ctmcp-answers/blob/master/Section06/expr5.mkd

% > 後者(= Mobile value)はWrap, Unwrapに対応する．
% > Wrap,Unwrapはその実装のために名前値とチャンクを必要とする。名前値を生成するためには明示的状態が必要なため、バンドルされているデータ抽象を構築するためには、明示的状態が必要であると言える。
