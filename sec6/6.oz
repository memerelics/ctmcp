%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                               6. 明示的状態                                 %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% 宣言的であるかどうか，はゼロイチではなく「度合い」である

% 6.1. 明示的状態の導入
% 6.2. システム設計の基本原則と状態
% 6.3. 状態あり計算モデルの定義
% 6.4. 明示的状態がある場合とない場合のデータ抽象
% 6.5. 有用な状態ありADT -- コレクション
% 6.6. 不変表明と状態の議論
% 6.7. 大規模プログラミング (3.9の拡張)
% 6.8. ケーススタディ
% 6.9. より進んだ話題


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 6.1. 状態とは何か?
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% > 状態(state)とは，必要とされる計算の途中結果を含む値の時系列である．

%% 6.1.1. 暗黙的(宣言的)状態

% 宣言的関数SumList
fun {SumList Xs S}
   case Xs
   of nil then S
   [] X|Xr then {SumList Xr X+S}
   end
end

% > SumListは状態を伴って計算している．しかし，プログラムも計算モデルもこのことを「知っている(know)」わけではない．この状態は，完全にプログラマの心のなかにある．


%% 6.1.2. 明示的状態

% > 手続きの中の明示的状態とは，
% > その生存期間が二度以上の手続き呼び出しにわたるような1つの状態で，
% > 手続きの引数に現れないものである．

% モデルを拡張: 「状態あり(stateful)モデル」
% Cellという一種のコンテナを持たせる．Cellは無限の生存期間，変更可能な内容を持つ．
% これにより宣言的プログラミングの限界(p.325 / 4.8)を打破する．

% たとえば単純な状態として，手続きが呼ばれた階数を保持するようにする．
% := は新しい内容を入れ，@で参照する．

% セルを使って，SumListに長期記憶を追加する．
% たとえば，SumList自身が何度呼ばれたかを記憶させる．
local
    C={NewCell 0}
in
   fun {SumList Xs S}
      C:=@C+1
      case Xs
      of nil then S
      [] X|Xr then {SumList Xr X+S}
      end
   end
   fun {SumCount} @C end
end


% > 明示的状態へのアクセスは，そのデータ抽象の操作に制限される．
% > この考え方はオブジェクト指向システムの核心である．


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 6.2. 状態とシステム構築
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% 人間の思考能力は有限．抽象化は最も成功したシステム構築原則．

% 宣言的プログラミングはその知識のすべてを自分の外(環境)に持つ．
% 新しい知識をコンポーネントの中に入れることが出来ないため，宣言的プログラミングではうまく抽象化が支援されていない．


%% 6.2.1. システムの性質

% 抽象化を支援するために持つべき性質は
% * カプセル化
% * 合成可能性
% * 具体化/起動

% カプセル化の導入により「不変表明(invariant)」が可能となる．
% あるコンポーネントの不変表明は「そのコンポーネントが間違った振る舞いをしていない」というだけ

% 複雑なシステムはなるべく多くを宣言的にして，状態は小数のコンポーネントに持たせるべき．


%% 6.2.2. コンポーネントベースプログラミング

% コンポーネント，は別にいま出てきた概念ではない．手続き抽象，ファンクタ，並列コンポーネント．


%% 6.2.3. オブジェクト指向プログラミング

% 状態ありプログラミング技法の集合としてよく知られている．
% オブジェクト(object)を独特のデータ抽象化法として持つ．

% 「継承」はコンポーネントベースプログラミングにはない新しい概念である．
% 継承の定義は「既存のデータ抽象を漸増的に拡張すること」で，利点は共通化による重複排除．
% 漸増的に構築されるコンポーネントを「クラス」と言う．クラスの具体化が「オブジェクト」である．

% > あるコンポーネントが，継承元のコンポーネントに強く依存することを意味する．この依存関係は扱いにくい．
% > オブジェクト指向設計，たとえばデザインパターンに関する文献の多くは，継承の正しい使い方に的を絞っている．

% 可能な限りコンポーネント合成を使い，それで足りない時だけ継承を使うべき．


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 6.3. 明示的状態を持つ宣言的モデル
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% 6.3.1. セル

% 操作: NewCell, :=, Exchange(X=C:=Yとも書ける)

%% 6.3.2. セルの意味

% 実行状態モデルの拡張．

%% 6.3.3. 宣言的プログラミングとの関係

% 状態ありプログラミングはもはや宣言的ではない．
% が，宣言的に振る舞うようなコンポーネントを書くことはできるしそれを設計目標とすべき．

%% 6.3.4. 共有と同等

% セルの導入によって，セルの同等性と内容の同等性を区別する必要が発生する．
% 共有(sharing)と字句同等性(token equality)


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 6.4. データ抽象
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% => ./6.4.oz


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 6.5. 状態ありコレクション
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% 図6.4 -- インデックス付きコレクションのいろいろ
% タプル   = 状態ナシのシーケンス
% 配列     = タプルに状態を付与したもの
% レコード = 数字以外の添字を許可したもの
% 辞書     = 数字以外の添字を許可し，さらに状態を付与したもの

% インデックスあり =>
% 配列の添字とか辞書のKeyを指定してやれば定数時間でデータが帰ってくる

% 6.5.3 その他のコレクション

% インデックスなしコレクション
% たとえばリストとストリームはインデックスなしコレクション.

% 拡張可能配列
% 拡張可能配列いままで出てきたもの = {ストリーム, 辞書}
% ストリーム: 効率よく拡張, 要素へのアクセス効率は良くない

% 図6.5 拡張可能配列(状態あり)
% https://www.info.ucl.ac.be/~pvr/bookfigures/fig6_5.oz
declare
fun {NewExtensibleArray L H Init}
   A={NewCell {NewArray L H Init}}#Init
   proc {CheckOverflow I}
      Arr=@(A.1)
      Low={Array.low Arr}
      High={Array.high Arr}
   in
      if I>High then
         High2=Low+{Max I 2*(High-Low)}
         Arr2={NewArray Low High2 A.2}
      in
         for K in Low..High do Arr2.K:=Arr.K end
         (A.1):=Arr2
      end
   end
   proc {Put I X}
      {CheckOverflow I}
      @(A.1).I:=X
   end
   fun {Get I}
      {CheckOverflow I}
      @(A.1).I
   end
in extArray(get:Get put:Put)
end


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 6.6. 状態に関する推論
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% 状態が入ってきたことによって今まで使ってきた証明が難しくなってしまった
% それをなんとかするために不変表明(invariant assertion)を導入する
% 不変表明の技法は公理的意味(axiomatic semantics)と言う.
% 正しさの規則は「公理(axiom)」と呼ばれ, 以降この呼称が定着.

% 「操作Oiの直前にAiが真であれば, Oiが終了したときBiが真になる」
% {Ai} Oi {Bi}

% 部分正確性表明(partial correctness assertion)とは,
% Oiが正常に終了したときに限って正しい, という意味での"部分"

% 6.6.2 例

% stack生成の言明
{true}
Stack={NewStack}
{@c = nil ^ Stack = ops(push:Push pop:Pop isEmpty:IsEmpty)}

% Stackの中身を隠ぺいする述語stachContentを定義して読みやすくする. cはStackに対応する内部セルとする.

% stackContent(Stack, S) ≡ @c = S

% これを使うと, NewStackとかpush操作を次のように表せる
{true}
Stack={NewStack}
{stackContent(Stack, nil) ^
 Stack = ops(push:Push pop:Pop isEmtpy:IsEmpty)}

% もいっちょ
{stackContent(Stack, S)}
{Stack.push X}
{stackContent(Stack, X|S)}

% なおこれらの言明は, 操作が例外を発生した時にどうなるかについては何も言わない.

% データ抽象の正しさを表明すること
% スタックがどのように振る舞う"べき"かを以上で示したが，
% 実装はちゃんとそうなっているだろうか?
% => 部分正確性表明のそれぞれが実装に対して正しいかどうかをチェック

% 仮に実装はこんな感じだったとしよう
fun {NewStack}
   C={NewCell nil}
   proc {Push X} S in S=@C C:=X|S end
   fun {Pop} S1 in
      S1=@C
      case S1 of X|S then C:=S X end
   end
   fun {IsEmpty} S in S=@C S==nil end
in
   ops(push:Push pop:Pop isEmpty:IsEmpty)
end

% Push操作の部分正確性表明を検証しよう.
{@C = s}
S=@C
C:=X|S
{@C = X|s}

% さらに脱線, セル操作@と:=の仕様を知る必要がある.
% まず@.
{P}
<y> = @<x>
{P ^ <y> = @<x>}

% <y> : 識別子
% <x> : セルに束縛された識別子

% := の仕様
{P(<exp>)}
<x>:=<exp>
{P(@<x>)}

% 束縛の仕様
{P} <x> = <exp> {P ^ <x> = <exp>}
% ;; 後半よくわからんかったけど P && (x == exp) みたいなイメージ

% if文の形式
% 条件式がtrueなら式1, falseなら式2が実行される, という前提さえ成り立てばif文の形式は正しさを証明できる.
% 数理論理学の本で読んだ証明規則の書き方で, 横線の上に前提, 下に結論を配置する
{P ^ <x> = true } <stmt>1 {Q}
{P ^ <x> = false} <stmt>2 {Q}
------------------------------
{P} if <x> then <stmt>1 else <stmt>2 end {Q}


% whileが面白い
{P ^ <expr>} <stmt> {P}
----------------------------------------------
{P} while <expr> do <stmt> end {P ^ ¬<expr>}

% whileを抜けた...ってことは<expr>が偽になっているはず

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 6.8. ケーススタディ
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% => ./6.8.oz へ分割

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 6.9. 進んだ話題
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% => ./6.9.oz