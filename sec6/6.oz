%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                               6. 明示的状態                                 %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% 宣言的であるかどうか，はゼロイチではなく「度合い」である

% 6.1. 明示的状態の導入
% 6.2. システム設計の基本原則と状態
% 6.3. 状態あり計算モデルの定義
% 6.4. 明示的状態がある場合とない場合のデータ抽象
% 6.5. 有用な状態ありADT -- コレクション
% 6.6. 不変表明と状態の議論
% 6.7. 大規模プログラミング (3.9の拡張)
% 6.8. ケーススタディ
% 6.9. より進んだ話題


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 6.1. 状態とは何か?
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% > 状態(state)とは，必要とされる計算の途中結果を含む値の時系列である．

%% 6.1.1. 暗黙的(宣言的)状態

SumList

%% 6.1.2. 明示的状態

% > 手続きの中の明示的状態とは，
% > その生存期間が二度以上の手続き呼び出しにわたるような1つの状態で，
% > 手続きの引数に現れないものである．

% モデルを拡張: 「状態あり(stateful)モデル」
% Cellという一種のコンテナを持たせる．Cellは無限の生存期間，変更可能な内容を持つ．
% これにより宣言的プログラミングの限界(p.325 / 4.8)を打破する．

% たとえば単純な状態として，手続きが呼ばれた階数を保持するようにする．
% := は新しい内容を入れ，@で参照する．
local
    C={NewCell 0}
in
...

% > 明示的状態へのアクセスは，そのデータ抽象の操作に制限される．
% > この考え方はオブジェクト指向システムの核心である．


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 6.2. 状態とシステム構築
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% 人間の思考能力は有限．抽象化は最も成功したシステム構築原則．

% 宣言的プログラミングはその知識のすべてを自分の外(環境)に持つ．
% 新しい知識をコンポーネントの中に入れることが出来ないため，宣言的プログラミングではうまく抽象化が支援されていない．


%% 6.2.1. システムの性質

% 抽象化を支援するために持つべき性質は
% * カプセル化
% * 合成可能性
% * 具体化/起動

% カプセル化の導入により「不変表明(invariant)」が可能となる．
% あるコンポーネントの不変表明は「そのコンポーネントが間違った振る舞いをしていない」というだけ

% 複雑なシステムはなるべく多くを宣言的にして，状態は小数のコンポーネントに持たせるべき．


%% 6.2.2. コンポーネントベースプログラミング

% コンポーネント，は別にいま出てきた概念ではない．手続き抽象，ファンクタ，並列コンポーネント．


%% 6.2.3. オブジェクト指向プログラミング

% 状態ありプログラミング技法の集合としてよく知られている．
% オブジェクト(object)を独特のデータ抽象化法として持つ．

% 「継承」はコンポーネントベースプログラミングにはない新しい概念である．
% 継承の定義は「既存のデータ抽象を漸増的に拡張すること」で，利点は共通化による重複排除．
% 漸増的に構築されるコンポーネントを「クラス」と言う．クラスの具体化が「オブジェクト」である．

% > あるコンポーネントが，継承元のコンポーネントに強く依存することを意味する．この依存関係は扱いにくい．
% > オブジェクト指向設計，たとえばデザインパターンに関する文献の多くは，継承の正しい使い方に的を絞っている．

% 可能な限りコンポーネント合成を使い，それで足りない時だけ継承を使うべき．


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 6.3. 明示的状態を持つ宣言的モデル
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% 6.3.1. セル

% 操作: NewCell, :=, Exchange(X=C:=Yとも書ける)

%% 6.3.2. セルの意味

% 実行状態モデルの拡張．

%% 6.3.3. 宣言的プログラミングとの関係

% 状態ありプログラミングはもはや宣言的ではない．
% が，宣言的に振る舞うようなコンポーネントを書くことはできるしそれを設計目標とすべき．

%% 6.3.4. 共有と同等

% セルの導入によって，セルの同等性と内容の同等性を区別する必要が発生する．
% 共有(sharing)と字句同等性(token equality)


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 6.4. データ抽象
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% データ抽象とはその実装にとらわれずデータを使うこと．

% > データ抽象を「型(type)」といって済ますこともある．

% 3.7(p.201)で紹介した抽象データ型(ADT)は，特殊なデータ抽象．データを抽象的に扱う方法はADTだけではない．

%% 6.4.1. データ抽象を組織する8つの方法

% * 開放性と安全性 (開放 or 安全)
% * バンドリング
% * 明示的状態

% 図6.2


%% 6.4.2. スタックの変種

コード例

%% 6.4.3. 多態性

% 多態性(polymorphism) = ある実体が多くの形態を取る能力

% ADTとオブジェクトをどう使い分けるか，の比較考察 p.441

%% 6.4.4. 引数受け渡し

% 参照呼び出し(call by reference)
% 変数呼び出し(call by variable)
% 値呼び出し(call by value)
% 入出力呼び出し(call by value-result)
% 名前呼び出し(call by name)
% 要求呼び出し(call by need)

%% 6.4.5. 取り消し可能資格(revocable capability)
