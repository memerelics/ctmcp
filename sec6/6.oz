%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                               6. 明示的状態                                 %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% 宣言的であるかどうか，はゼロイチではなく「度合い」である

% 6.1. 明示的状態の導入
% 6.2. システム設計の基本原則と状態
% 6.3. 状態あり計算モデルの定義
% 6.4. 明示的状態がある場合とない場合のデータ抽象
% 6.5. 有用な状態ありADT -- コレクション
% 6.6. 不変表明と状態の議論
% 6.7. 大規模プログラミング (3.9の拡張)
% 6.8. ケーススタディ
% 6.9. より進んだ話題


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 6.1. 状態とは何か?
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% > 状態(state)とは，必要とされる計算の途中結果を含む値の時系列である．

%% 6.1.1. 暗黙的(宣言的)状態

% SumList

%% 6.1.2. 明示的状態

% > 手続きの中の明示的状態とは，
% > その生存期間が二度以上の手続き呼び出しにわたるような1つの状態で，
% > 手続きの引数に現れないものである．

% モデルを拡張: 「状態あり(stateful)モデル」
% Cellという一種のコンテナを持たせる．Cellは無限の生存期間，変更可能な内容を持つ．
% これにより宣言的プログラミングの限界(p.325 / 4.8)を打破する．

% たとえば単純な状態として，手続きが呼ばれた階数を保持するようにする．
% := は新しい内容を入れ，@で参照する．

% local
%     C={NewCell 0}
% in
% ...

% > 明示的状態へのアクセスは，そのデータ抽象の操作に制限される．
% > この考え方はオブジェクト指向システムの核心である．


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 6.2. 状態とシステム構築
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% 人間の思考能力は有限．抽象化は最も成功したシステム構築原則．

% 宣言的プログラミングはその知識のすべてを自分の外(環境)に持つ．
% 新しい知識をコンポーネントの中に入れることが出来ないため，宣言的プログラミングではうまく抽象化が支援されていない．


%% 6.2.1. システムの性質

% 抽象化を支援するために持つべき性質は
% * カプセル化
% * 合成可能性
% * 具体化/起動

% カプセル化の導入により「不変表明(invariant)」が可能となる．
% あるコンポーネントの不変表明は「そのコンポーネントが間違った振る舞いをしていない」というだけ

% 複雑なシステムはなるべく多くを宣言的にして，状態は小数のコンポーネントに持たせるべき．


%% 6.2.2. コンポーネントベースプログラミング

% コンポーネント，は別にいま出てきた概念ではない．手続き抽象，ファンクタ，並列コンポーネント．


%% 6.2.3. オブジェクト指向プログラミング

% 状態ありプログラミング技法の集合としてよく知られている．
% オブジェクト(object)を独特のデータ抽象化法として持つ．

% 「継承」はコンポーネントベースプログラミングにはない新しい概念である．
% 継承の定義は「既存のデータ抽象を漸増的に拡張すること」で，利点は共通化による重複排除．
% 漸増的に構築されるコンポーネントを「クラス」と言う．クラスの具体化が「オブジェクト」である．

% > あるコンポーネントが，継承元のコンポーネントに強く依存することを意味する．この依存関係は扱いにくい．
% > オブジェクト指向設計，たとえばデザインパターンに関する文献の多くは，継承の正しい使い方に的を絞っている．

% 可能な限りコンポーネント合成を使い，それで足りない時だけ継承を使うべき．


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 6.3. 明示的状態を持つ宣言的モデル
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% 6.3.1. セル

% 操作: NewCell, :=, Exchange(X=C:=Yとも書ける)

%% 6.3.2. セルの意味

% 実行状態モデルの拡張．

%% 6.3.3. 宣言的プログラミングとの関係

% 状態ありプログラミングはもはや宣言的ではない．
% が，宣言的に振る舞うようなコンポーネントを書くことはできるしそれを設計目標とすべき．

%% 6.3.4. 共有と同等

% セルの導入によって，セルの同等性と内容の同等性を区別する必要が発生する．
% 共有(sharing)と字句同等性(token equality)


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 6.4. データ抽象
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% データ抽象とはその実装にとらわれずデータを使うこと．

% > データ抽象を「型(type)」といって済ますこともある．

% 3.7(p.201)で紹介した抽象データ型(ADT)は，特殊なデータ抽象．データを抽象的に扱う方法はADTだけではない．

%% 6.4.1. データ抽象を組織する8つの方法

% * 開放性と安全性 (開放 or 安全)
% * バンドリング
% * 明示的状態

% 図6.2


%% 6.4.2. スタックの変種

% コード例

%% 6.4.3. 多態性

% 多態性(polymorphism) = ある実体が多くの形態を取る能力

% ADTとオブジェクトをどう使い分けるか，の比較考察 p.441

%% 6.4.4. 引数受け渡し

% 参照呼び出し(call by reference)
  % 言語実体のアイデンティティが手続きに渡される.
  % その言語における定義を調べてから論じるべき. 命令的言語で「参照呼び出し」と言っても本書の用語では値呼び出しに相当するかもと
% 変数呼び出し(call by variable)
  % 参照呼び出しの特殊な場合.
  % "セルの"アイデンティティが手続きに渡される
% 値呼び出し(call by value)
  % 呼び出した手続き内で破壊的操作を行ってもそれが本体に及ばない
  % 本書においては「手続きに値が渡され, その手続きに局所的なセルに格納される」こと
% 入出力呼び出し(call by value-result)
% 名前呼び出し(call by name)
  % 引数を関数でwrapしてやって評価時にいちいち呼び出す. thunk.
% 要求呼び出し(call by need)
  % 名前呼び出し(call by name)の特殊な場合.
  % thunkは高々1回呼ばれ, その結果はメモ化される.

% Cで言うとポインタを投げる, のが参照呼び出し?

% 本書で使っている核言語手法の目的は基本/原始的な機能を切り出すことなので,
% 参照呼び出しを採用する. これはセル・手続き値といった余分な概念に依存しない.


%% 6.4.5. 取り消し可能資格(revocable capability)

% 明示的状態を使って, revocable capabilityをいかに構築するか.
% 「資格(capability)」という概念は3章で導入

% 任意の"手続き" Objを受け取り,
% 取り消し手続きRと,
% 取り消し可能版RObjを返す.
proc {Revocable Obj ?R ?RObj}
   C={NewCell Obj}
in
   proc {R}
      C:=proc {$ M} raise revokedError end end
   end
   proc {RObj M}
      {@C M}
   end
end


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 6.5. 状態ありコレクション
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% 図6.4 -- インデックス付きコレクションのいろいろ
% タプル   = 状態ナシのシーケンス
% 配列     = タプルに状態を付与したもの
% レコード = 数字以外の添字を許可したもの
% 辞書     = 数字以外の添字を許可し，さらに状態を付与したもの

% インデックスあり =>
% 配列の添字とか辞書のKeyを指定してやれば定数時間でデータが帰ってくる

% 6.5.3 その他のコレクション

% インデックスなしコレクション
% たとえばリストとストリームはインデックスなしコレクション.

% 拡張可能配列
% 拡張可能配列いままで出てきたもの = {ストリーム, 辞書}
% ストリーム: 効率よく拡張, 要素へのアクセス効率は良くない

% 図6.5 拡張可能配列(状態あり)
% https://www.info.ucl.ac.be/~pvr/bookfigures/fig6_5.oz
declare
fun {NewExtensibleArray L H Init}
   A={NewCell {NewArray L H Init}}#Init
   proc {CheckOverflow I}
      Arr=@(A.1)
      Low={Array.low Arr}
      High={Array.high Arr}
   in
      if I>High then
         High2=Low+{Max I 2*(High-Low)}
         Arr2={NewArray Low High2 A.2}
      in
         for K in Low..High do Arr2.K:=Arr.K end
         (A.1):=Arr2
      end
   end
   proc {Put I X}
      {CheckOverflow I}
      @(A.1).I:=X
   end
   fun {Get I}
      {CheckOverflow I}
      @(A.1).I
   end
in extArray(get:Get put:Put)
end


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 6.6. 状態に関する推論
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% 状態が入ってきたことによって今まで使ってきた証明が難しくなってしまった
% それをなんとかするために不変表明(invariant assertion)を導入する
% 不変表明の技法は公理的意味(axiomatic semantics)と言う.
% 正しさの規則は「公理(axiom)」と呼ばれ, 以降この呼称が定着.

% 「操作Oiの直前にAiが真であれば, Oiが終了したときBiが真になる」
% {Ai} Oi {Bi}

% 部分正確性表明(partial correctness assertion)とは,
% Oiが正常に終了したときに限って正しい, という意味での"部分"

% 6.6.2 例

% stack生成の言明
{true}
Stack={NewStack}
{@c = nil ^ Stack = ops(push:Push pop:Pop isEmpty:IsEmpty)}

% Stackの中身を隠ぺいする述語stachContentを定義して読みやすくする. cはStackに対応する内部セルとする.

% stackContent(Stack, S) ≡ @c = S

% これを使うと, NewStackとかpush操作を次のように表せる
{true}
Stack={NewStack}
{stackContent(Stack, nil) ^
 Stack = ops(push:Push pop:Pop isEmtpy:IsEmpty)}

% もいっちょ
{stackContent(Stack, S)}
{Stack.push X}
{stackContent(Stack, X|S)}

% なおこれらの言明は, 操作が例外を発生した時にどうなるかについては何も言わない.

% データ抽象の正しさを表明すること
% スタックがどのように振る舞う"べき"かを以上で示したが，
% 実装はちゃんとそうなっているだろうか?
% => 部分正確性表明のそれぞれが実装に対して正しいかどうかをチェック

% 仮に実装はこんな感じだったとしよう
fun {NewStack}
   C={NewCell nil}
   proc {Push X} S in S=@C C:=X|S end
   fun {Pop} S1 in
      S1=@C
      case S1 of X|S then C:=S X end
   end
   fun {IsEmpty} S in S=@C S==nil end
in
   ops(push:Push pop:Pop isEmpty:IsEmpty)
end

% Push操作の部分正確性表明を検証しよう.
{@C = s}
S=@C
C:=X|S
{@C = X|s}

% さらに脱線, セル操作@と:=の仕様を知る必要がある.
% まず@.
{P}
<y> = @<x>
{P ^ <y> = @<x>}

% <y> : 識別子
% <x> : セルに束縛された識別子

% := の仕様
{P(<exp>)}
<x>:=<exp>
{P(@<x>)}

% 束縛の仕様
{P} <x> = <exp> {P ^ <x> = <exp>}
% ;; 後半よくわからんかったけど P && (x == exp) みたいなイメージ

% if文の形式
% 条件式がtrueなら式1, falseなら式2が実行される, という前提さえ成り立てばif文の形式は正しさを証明できる.
% 数理論理学の本で読んだ証明規則の書き方で, 横線の上に前提, 下に結論を配置する
{P ^ <x> = true } <stmt>1 {Q}
{P ^ <x> = false} <stmt>2 {Q}
------------------------------
{P} if <x> then <stmt>1 else <stmt>2 end {Q}


% whileが面白い
{P ^ <expr>} <stmt> {P}
----------------------------------------------
{P} while <expr> do <stmt> end {P ^ ¬<expr>}

% whileを抜けた...ってことは<expr>が偽になっているはず

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 6.8. ケーススタディ
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% => ./6.8.oz へ分割

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 6.9. 進んだ話題
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% オブジェクト指向プログラミングは状態ありプログラミングの特別な場合
% 限界: 並列性，AND/OR 分散と共存するのが難しい
% 状態あり分散プログラミングはトリッキー


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 6.10. 練習問題
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% q6-7 取り消し可能資格
% revoke呼ぶと...手続きの呼び出しを禁止する.
% 引数を1個にすることで，資格を取り消す能力を取り消し可能にすることができる

% q6-8
% パターン1は瞬間的に使用するメモリ量が大きく, GCにやさしくない
% パターン2は表面に現れているペアが(パターン1の3個に対し)1個しかないのでやさしい
