%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 2.8 進んだ話題
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% 2.8.1 関数型プログラミング言語
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% > 関数型プログラミングとは, 完全値についての関数を定義することである. ここに出てくる関数は, 数学的な意味における本当の関数である.
%% >
%% > p.98

%% そしてその「数学的な意味における本当の関数」のみを利用して計算するような言語は「純粋関数型言語」と言う.
%% 純粋関数型計算はλ計算という形式化に基づいている.
%% λ計算は以下の2つからなる
%%     1. 関数を定義すること
%%     2. 関数を計算すること

%% λという記号は「名前のない関数」を仮に記述するための取り決め, だろうか?
%% 表示としてはλ式は以下の2つからなる
%%     1. ドットの前: 引数
%%     2. ドットの後: 結果

fun {IsNil X} X==nil end
fun {IsCons X} case X of _|_ then true else false end end
fun {Car H|T} H end
fun {Cdr H|T} T end
fun {Cons H T} H|T end

Append=fun {$ Xs Ys}
          if {IsNil Xs} then Ys
             else {Cons {Car Xs} {Append {Cdr Xs} Ys}}
          end
       end

%% このAppendは以下のラムダ式に等しい
%% append = λxs,ys. if isNil...

%% 宣言的モデルに以下の制限を加える事で関数型プログラミング言語として定義できる.
%%     * 変数を宣言するときは直ちに値に束縛する(未定義状態を許さない)
%%     * 手続きを使わず, 関数だけを使う.
%% これだけで, 高階プログラミング技法のすべてが利用可能になる.

%% 関数型プログラミング言語の変種/追加機能をいくつか

%% > 宣言的モデルにおいて, 関数はデフォルトとして性急(eager)である. すなわち, 関数の引数は, 関数本体の実行前に計算される. このことは正格計算(strict evaluation)とも言われる. 関数型言語SchemeとStandart MLは正格である.
%% > もうひとつの有用な計算方式, 遅延計算(lazy evaluation)がある. これは, 関数の引数をその値が必要なときに初めて計算する方式である. Haskellはその方式を採っている. 遅延計算は, 関数型プログラミングにおける強力なフロー制御技法である.
%% > p.100


%% 2.8.2 単一化と内含(entailment)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% > 変数に値を束縛することは, 単一化(unification)と言われる操作の特殊な場合である
%% > p.101

%% 単一化操作 <Term1>=<Term2> は, 部分値<Term1>と部分値<Term2>を等しくする.
%% 部分値があるから単一化に意味があり, すべて束縛済の完全値しかなければ単一化は無意味.
