%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 2.8 進んだ話題
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% 2.8.1 関数型プログラミング言語
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% > 関数型プログラミングとは, 完全値についての関数を定義することである. ここに出てくる関数は, 数学的な意味における本当の関数である.
%% >
%% > p.98

%% そしてその「数学的な意味における本当の関数」のみを利用して計算するような言語は「純粋関数型言語」と言う.
%% 純粋関数型計算はλ計算という形式化に基づいている.
%% λ計算は以下の2つからなる
%%     1. 関数を定義すること
%%     2. 関数を計算すること

%% λという記号は「名前のない関数」を仮に記述するための取り決め, だろうか?
%% 表示としてはλ式は以下の2つからなる
%%     1. ドットの前: 引数
%%     2. ドットの後: 結果

fun {IsNil X} X==nil end
fun {IsCons X} case X of _|_ then true else false end end
fun {Car H|T} H end
fun {Cdr H|T} T end
fun {Cons H T} H|T end

Append=fun {$ Xs Ys}
          if {IsNil Xs} then Ys
             else {Cons {Car Xs} {Append {Cdr Xs} Ys}}
          end
       end

%% このAppendは以下のラムダ式に等しい
%% append = λxs,ys. if isNil...

%% 宣言的モデルに以下の制限を加える事で関数型プログラミング言語として定義できる.
%%     * 変数を宣言するときは直ちに値に束縛する(未定義状態を許さない)
%%     * 手続きを使わず, 関数だけを使う.
%% これだけで, 高階プログラミング技法のすべてが利用可能になる.

%% 関数型プログラミング言語の変種/追加機能をいくつか

%% > 宣言的モデルにおいて, 関数はデフォルトとして性急(eager)である. すなわち, 関数の引数は, 関数本体の実行前に計算される. このことは正格計算(strict evaluation)とも言われる. 関数型言語SchemeとStandart MLは正格である.
%% > もうひとつの有用な計算方式, 遅延計算(lazy evaluation)がある. これは, 関数の引数をその値が必要なときに初めて計算する方式である. Haskellはその方式を採っている. 遅延計算は, 関数型プログラミングにおける強力なフロー制御技法である.
%% > p.100


%% 2.8.2 単一化と内含(entailment)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% > 変数に値を束縛することは, 単一化(unification)と言われる操作の特殊な場合である
%% > p.101

%% 単一化操作 <Term1>=<Term2> は, 部分値<Term1>と部分値<Term2>を等しくする.
%% 部分値があるから単一化に意味があり, すべて束縛済の完全値しかなければ単一化は無意味.

%% 単一化は引数について対称である. たとえば以下を実行するとX1, X2の双方が束縛される.
%%     person(name: "George" age: X2)
%%     person(name: X1 age: 25)

%% 単一化で循環構造を作る
%%     X=person(grandfather:X)

%% さらに, 単一化で循環構造を束縛できる.
%%     X=f(a:X b:_)
%%     Y=f(a:_ b:Y)
%%     X=Y
%% この3ツの単一化によって, 以下のように表すことの出来る構造が生成される.
%%     X=f(a:X b:X)
%% https://dl.dropboxusercontent.com/s/vxkvpn46euviq1x/2014-09-30%20at%204.26%20PM.png?dl=0

%% 2.8.2.2 単一化のアルゴリズム

%% unify(x, y)を「2つの部分値xとyを格納域σの中で単一化する操作」と定義する.
%% https://dl.dropboxusercontent.com/s/l5a5w7155gufit0/2014-09-30%20at%207.55%20PM.png?dl=0
%% 言葉は(正確に表すため)ややこしいが意味は明快.

%% > 格納域変数を単一化の文脈で使うときは, 論理変数(logic variable)と言う. 論理型プログラミングは関係プログラミング(relational programming)とも言われ
%% p.103

%% 先に書いた循環構造を扱うためには?
%% 1ツの方法は, あり得る対(x, y)のそれぞれについてunify(x, y)が高々1回しか呼ばれないようにすること.


%% 小文字が値. 大文字が変数

declare X Y Z
local X Y Z in
   f(X b)=f(a Y)    %% X, Yはふつうにunify, 束縛される
   f(Z a)=Z         %% Zは循環構造.
   {Browse [X Y Z]} %% RepresentationをGraphにすれば循環表現が可能.
end

declare X Y Z in
a(X c(Z) Z)=a(b(Y) Y d(X))
{Browse X#Y#Z}

%% こんがらがる...

%% 2.8.2.4 内含(ないがん: entailment)チェックと反駁(はんばく?: disentailment)チェック
%% ==と/=のこと.

declare L1 L2 L3 Head Tail in
L1=Head|Tail
Head=1
Tail=2|nil

L2=[1 2]
{Browse L1==L2} % => true

L3='|'(1:1 2:'|'(2 nil))
{Browse L1==L3} % => true

%% 内含チェックが判断できない例は
declare L1 L2 X in
L1=[1]
L2=[X]
{Browse L1==L2} % この時点ではブロックされる.
X=1             % これを投入すればtrueが表示される...と言うが, されないな

declare L1 L2 X in
L1=[X]
L2=[X]
{Browse L1==L2} % 今回は, Xが束縛されてなくてもtrue.

declare L1 L2 X in
L1=[1 a]
L2=[X b]
{Browse L1==L2} % => false. ブロックして束縛を待たなくても(a,bという)違いがわかるので.


%% 2.8.3 動的型付けと静的型付け
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% 言語は強く型付けされていることが重要である
%% 強い型付けには主要な族が二つある.
%%   * 動的型付け(dynamic typing) -- 変数の型は実行時にしかわからない
%%   * 静的型付け(static typing) -- すべての変数の型はコンパイル時にわかっている
%%     * 型はプログラマが宣言するか, コンパイラが推測する.

%% 動的型付はどんな型が入るかわからない変数に対して「なんでも入る格納域」を用意する必要があり効率が悪い.
%% 選択は理性ではなく感情により行われることが多い.

%% Ozは動的型付け. なぜならいくつかのプログラミングパラダイムを統合したモデルでどんなプログラミング技法が可能か解明することが当プロジェクトの目的であるため.
