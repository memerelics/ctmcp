3.6 高階プログラミング

手続きが何階でも積み重なってよいプログラミング.

高階プログラミング

1. 手続き抽象(procedural abstraction): 任意の文を手続き値に変換する能力
    * proc
2. 汎用性(genericity): 手続き呼び出しの引数に手続き値を渡す能力.
3. 具体化(instantiation): 手続き呼び出しの結果として手続き値を返す能力.
4. 埋め込み(embedding): データ構造の中に手続き値を入れる能力.


#### 手続き抽象.

手続き抽象の制限された形
CやPascalでは手続きを入れ子にできなかったり変数のスコープが制限されてて,
高階プログラミングの技法の多くが使えなかったり.


#### 汎用性.

任意の手続きを手続きに渡して利用できること.
マージソートを汎用化.
3.4.2で作ったマージソートは比較関数`<`をベタ書きで使っていたが,
任意の比較関数を

マージソートの汎用化, 中の比較に「<」を使う代わりに任意の比較関数を渡せるようにする... なるほど. 比較操作の条件を満たしてることを保証させたくなる

p.188のfun {$ A B} A<B 例は無名関数か.
その代わりにValue.'>'を使ってもいいっぽい. Mozartだと.


#### 具体化

ソート関数を返すMakeSort, みたいな.
factoryとかgeneratorと呼ばれることもある.


#### 埋め込み

手続き値をデータ構造に入れる. (明示的)遅延計算(lazy evaluation)はこれか!


3.6.2 ループ抽象

宣言的モデルにおけるループは, 明示的な再帰呼び出しが必要になるので冗長になりがち.
なので(再帰を中にラッピングしただけの)forループを定義してみよう.

整数ループ
LoopUp/Down

{For 1 10 <step> MyProc}
1 1でも1回は実行される.

リストループ. Listを受け取りcaseでnilになるまで再帰.

ここまでのFor系は操作を実行するだけで何も結果を返さない, 宣言的モデルではこれは全く役立たない
結果を返すaccumulatorさんを定義しよう


accumulatorを別の見方をすると, リストの各要素に中間演算子を"挟み込ん"でいるとも見える.
演算子が右結合か左結合か, でカッコのくくりかたが違ってくると

"アキュームレータが表に出ていない"とは一体...

Loop中で{Browse X#U}とかして確かめる

3.6.2まで進行.