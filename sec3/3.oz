%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 3.1 宣言的とはどういうことか？
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% 宣言的とは: 「どのように」を説明せず「何」を定義することでプログラムすること


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 3.2 反復計算
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% 反復計算はループで, そのスタックの大きさは反復回数によらず, 一定を超えないものである.
%% あるプログラムが反復的であるかどうかは必ずしも明らかではない.

%% 一般的図式
%% S0 -> S1 -> ... -> Sfinal
fun {Iterate S_i}
   if {IsDone S_i} then S_i
   else S_(i+1) in
      S_(i+1)={Transform S_i}
      {Iterate S_(i+1)}
   end
end


%% 3.2.2 数についての反復
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% ニュートン法


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 3.3 再帰計算
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% > 反復計算は, 再帰計算(recursive computation)というもっと一般的な計算の特殊ケースである
%% 反復計算とは要するに, あるアクションが何回か繰り返されるループである.
%% 再帰はより一般的で, その本体のどこででも自分自身を呼び出すことが出来, 2度以上呼び出すことも出来る.

%% 階乗をそのまま核言語に翻訳した以下の式は, 再帰呼び出しのあとに掛け算があることから,
%% 再帰呼び出しの最中に掛け算のための情報を保持しておく必要があり, スタックが大きくなりそうだと推測できる.
proc {Fact N ?R}
   if N==0 then R=1
   elseif N>0 then N1 R1 in
      N1=N-1
      {Fact N1 R1}
      R=N*R1
   else raise domainError end
   end
end

%% https://dl.dropboxusercontent.com/s/qunxux05hjbywy4/2014-10-14%20at%2011.02%20PM.png?dl=0


%% 3.3.3 再帰計算を反復計算に変換すること
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% R = (5*(4*(3*(2*1))))
%% これはそれぞれ「後で結果にかけるべき数」を記憶していく必要があるので, 記憶領域が増大していく.
%%
%% R = (((5*4)*3)*2)*1))
%% このように左結合に書き換えることで, 結果を次々置き換えるだけでstack消費しない.


%% 数学的な定義から反復にもってくのは自明ではないように見える. なんか小細工を弄してる感.
%% "何らかの理由付けをしなければならない" p.132
%% ;; あとで説明されるらしい

%% ;; メモ: 3.4.7は実際に動かない話なのでskipして3.4.8を先にやっていいかもとのこと.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 3.4 再帰を用いるプログラミング
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% 静的型付言語的なチェックをするのが目的ではない
%%
%% "手続きの型はその手続きのシグニチャ(signature)と言われることがある. その手続に関する主要情報を簡潔に伝えるからである."
%% CTMCP p.133
%%
%% 状態変換の列に作りなおすと反復にできる.
%%
%% 状態 Si = (i, Ys)
%%   i: 通過したものから持ち越した"結果". Lengthだと長さの値
%%   Ys: まだ通過してないもの
%%
%% 状態不変表明(state invariant)
%%
%% "状態不変表明になるようにiとYsが結合されている" とは?
%%
%% わかった(たぶん)
%%
%% まずS0,S1,...Sfinalまでのすべての状態において成り立つような状態の性質 P(Si) を見つける(この時点では正しいっぽい, とだけ)
%% それを帰納法で証明できる(証明できるなら他の方法でもいいだろうけど状態列だから帰納法が簡単だろう)
%%
%% 状態列の全てで成り立つ性質(状態不変表明: state invariant)を見つけて帰納法で証明することで関数の正しさが証明できる みたいな感じか. 再帰から(可能な場合)反復に変換することで証明できるようになる?
