%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 4.8. 宣言的プログラムの限界と拡張
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% 宣言的プログラミングはシステム構築がかなり単純になる．互いに独立に構築でき，デバッグ可能．

% プログラムが効率的であるとは:
%   アセンブリ言語で書くのに比べて性能が定数倍しか違わないこと
% プログラムが自然であるとは:
%   当面の問題に関係のない，技術的な理由だけから必要とされるコードがごくわずかであること．

% 自然さに関連する要素:
%   1. モジュラ性
%   2. 非決定性
%   3. 現実世界とのインターフェイス

% 宣言的プログラミングが効率的である例:
%   1. 大きなデータ構造を漸増的に修正するプログラム．しかし，状態がスレッド化されており，プログラムが古い状態に決してアクセスしないことがわかっていれば，内部実装で破壊的代入を使うことでデータ使用量域を抑えられる．
%   2. メモ化
%   3. 宣言的モデルは状態ありプログラムより表現力に劣る．遷移的閉包(transitive closure)アルゴリズムを宣言的モデルと状態ありモデルの両方で書いてみる．どちらも時間計算量はO(n^3)だけど，状態ありの方が書きやすい．6.8.1を先取り

% 状態あり版
proc {StateTrans GM}
   L={Array.low GM}
   H={Array.high GM}
in
   for K in L..H do
      for I in L..H do
         if GM.I.K then
            for J in L..H do
               if GM.K.J then GM.I.J:= true end
            end
         end
      end
   end
end

% 宣言的版(状態なし)
fun {DeclTrans2 GT}
   H={Width GT}
   fun {Loop K InG}
      if K=<H then
         G={MakeTuple g H} in
         for I in 1..H do
            G.I={MakeTuple g H}
            for J in 1..H do
               G.I.J = InG.I.J orelse (InG.I.K andthen InG.K.J)
            end
         end
         {Loop K+1 G}
      else InG end
   end
in
   {Loop 1 GT}
end

% 必要以上の表現力を持たさない．状態がいらないなら状態ナシでプログラミングしようねと

% シリアライザは要求を並列に受け取って直列になおしてやるコンポーネント．
% シリアライザを使うことで並列コンポーネントの中に直列コンポーネントを埋め込める．

% あとは状態ありモデルの中で状態なし(宣言的)モデルを使うとか．



%% 4.8.3. 非決定性
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% 4.8.3.1. クライアント/サーバアプリケーション

% 4.8.3.2. ビデオディスプレイアプリケーション
% ビデオフレームのストリームを受けとりそれを表示する
% 束縛されているかどうかの真偽を返す"IsDet"を使ってSkipを実装できる
fun {Skip Xs}
   if {IsDet Xs} then
      case Xs of _|Xr then {Skip Xr} [] nil then nil end
   else Xs end
end

% Skipはストリームを受けとり，束縛されていない末尾を返す．束縛されてない末尾が見つかるまで走査する．

% さらに別のバージョン．
fun {Skip1 Xs}
   case Xs of X|Xr then
      if {IsDet Xr} then {Skip1 Xr} else Xs end
   [] nil then nil end
end

% こちらのSkip1を使うと
% 「あるフレームを表示したあと，最も新しく転送されてきたフレームまでスキップする」
% というディスプレーヤを書くことが出来る

proc {Display Xs}
   case {Skip1 Xs}
      {DisplayFrame X}
      {Display Xr}
   [] nil then skip
   end
end


